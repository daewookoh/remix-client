import {
  require_browser
} from "./chunk-J7KEBB4U.js";
import {
  require_build
} from "./chunk-FZ4L5GXA.js";
import {
  init_esm,
  redirect2 as redirect
} from "./chunk-KOZXEZBA.js";
import {
  __publicField,
  __toESM
} from "./chunk-N5SXXOWC.js";

// node_modules/remix-auth-oauth2/build/index.js
init_esm();
var import_debug = __toESM(require_browser());
var import_remix_auth = __toESM(require_build());

// node_modules/@oslojs/binary/dist/uint.js
var BigEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] << 8 | data[offset + 1];
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << 24 - i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < offset + 1) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < offset + 2) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset] = value >> 8;
    target[offset + 1] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < offset + 4) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> (3 - i) * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < offset + 8) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt((7 - i) * 8) & 0xffn);
    }
  }
};
var LittleEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] | data[offset + 1] << 8;
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < 1 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < 2 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset + 1] = value >> 8;
    target[offset] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < 4 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> i * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < 8 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt(i * 8) & 0xffn);
    }
  }
};
var bigEndian = new BigEndian();
var littleEndian = new LittleEndian();

// node_modules/@oslojs/binary/dist/bits.js
function rotr32(x, n) {
  return (x << 32 - n | x >>> n) >>> 0;
}

// node_modules/@oslojs/crypto/dist/sha2/sha224.js
var K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);

// node_modules/@oslojs/crypto/dist/sha2/sha256.js
function sha256(data) {
  const hash = new SHA256();
  hash.update(data);
  return hash.digest();
}
var SHA256 = class {
  constructor() {
    __publicField(this, "blockSize", 64);
    __publicField(this, "size", 32);
    __publicField(this, "blocks", new Uint8Array(64));
    __publicField(this, "currentBlockSize", 0);
    __publicField(this, "H", new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]));
    __publicField(this, "l", 0n);
    __publicField(this, "w", new Uint32Array(64));
  }
  update(data) {
    this.l += BigInt(data.byteLength) * 8n;
    if (this.currentBlockSize + data.byteLength < 64) {
      this.blocks.set(data, this.currentBlockSize);
      this.currentBlockSize += data.byteLength;
      return;
    }
    let processed = 0;
    if (this.currentBlockSize > 0) {
      const next = data.slice(0, 64 - this.currentBlockSize);
      this.blocks.set(next, this.currentBlockSize);
      this.process();
      processed += next.byteLength;
      this.currentBlockSize = 0;
    }
    while (processed + 64 <= data.byteLength) {
      const next = data.slice(processed, processed + 64);
      this.blocks.set(next);
      this.process();
      processed += 64;
    }
    if (data.byteLength - processed > 0) {
      const remaining = data.slice(processed);
      this.blocks.set(remaining);
      this.currentBlockSize = remaining.byteLength;
    }
  }
  digest() {
    this.blocks[this.currentBlockSize] = 128;
    this.currentBlockSize += 1;
    if (64 - this.currentBlockSize < 8) {
      this.blocks.fill(0, this.currentBlockSize);
      this.process();
      this.currentBlockSize = 0;
    }
    this.blocks.fill(0, this.currentBlockSize);
    bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);
    this.process();
    const result = new Uint8Array(32);
    for (let i = 0; i < 8; i++) {
      bigEndian.putUint32(result, this.H[i], i * 4);
    }
    return result;
  }
  process() {
    for (let t = 0; t < 16; t++) {
      this.w[t] = (this.blocks[t * 4] << 24 | this.blocks[t * 4 + 1] << 16 | this.blocks[t * 4 + 2] << 8 | this.blocks[t * 4 + 3]) >>> 0;
    }
    for (let t = 16; t < 64; t++) {
      const sigma1 = (rotr32(this.w[t - 2], 17) ^ rotr32(this.w[t - 2], 19) ^ this.w[t - 2] >>> 10) >>> 0;
      const sigma0 = (rotr32(this.w[t - 15], 7) ^ rotr32(this.w[t - 15], 18) ^ this.w[t - 15] >>> 3) >>> 0;
      this.w[t] = sigma1 + this.w[t - 7] + sigma0 + this.w[t - 16] | 0;
    }
    let a = this.H[0];
    let b = this.H[1];
    let c = this.H[2];
    let d = this.H[3];
    let e = this.H[4];
    let f = this.H[5];
    let g = this.H[6];
    let h = this.H[7];
    for (let t = 0; t < 64; t++) {
      const sigma1 = (rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25)) >>> 0;
      const ch = (e & f ^ ~e & g) >>> 0;
      const t1 = h + sigma1 + ch + K2[t] + this.w[t] | 0;
      const sigma0 = (rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22)) >>> 0;
      const maj = (a & b ^ a & c ^ b & c) >>> 0;
      const t2 = sigma0 + maj | 0;
      h = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    this.H[0] = a + this.H[0] | 0;
    this.H[1] = b + this.H[1] | 0;
    this.H[2] = c + this.H[2] | 0;
    this.H[3] = d + this.H[3] | 0;
    this.H[4] = e + this.H[4] | 0;
    this.H[5] = f + this.H[5] | 0;
    this.H[6] = g + this.H[6] | 0;
    this.H[7] = h + this.H[7] | 0;
  }
};
var K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);

// node_modules/@oslojs/crypto/dist/sha2/sha512.js
var K3 = new BigUint64Array([
  0x428a2f98d728ae22n,
  0x7137449123ef65cdn,
  0xb5c0fbcfec4d3b2fn,
  0xe9b5dba58189dbbcn,
  0x3956c25bf348b538n,
  0x59f111f1b605d019n,
  0x923f82a4af194f9bn,
  0xab1c5ed5da6d8118n,
  0xd807aa98a3030242n,
  0x12835b0145706fben,
  0x243185be4ee4b28cn,
  0x550c7dc3d5ffb4e2n,
  0x72be5d74f27b896fn,
  0x80deb1fe3b1696b1n,
  0x9bdc06a725c71235n,
  0xc19bf174cf692694n,
  0xe49b69c19ef14ad2n,
  0xefbe4786384f25e3n,
  0x0fc19dc68b8cd5b5n,
  0x240ca1cc77ac9c65n,
  0x2de92c6f592b0275n,
  0x4a7484aa6ea6e483n,
  0x5cb0a9dcbd41fbd4n,
  0x76f988da831153b5n,
  0x983e5152ee66dfabn,
  0xa831c66d2db43210n,
  0xb00327c898fb213fn,
  0xbf597fc7beef0ee4n,
  0xc6e00bf33da88fc2n,
  0xd5a79147930aa725n,
  0x06ca6351e003826fn,
  0x142929670a0e6e70n,
  0x27b70a8546d22ffcn,
  0x2e1b21385c26c926n,
  0x4d2c6dfc5ac42aedn,
  0x53380d139d95b3dfn,
  0x650a73548baf63den,
  0x766a0abb3c77b2a8n,
  0x81c2c92e47edaee6n,
  0x92722c851482353bn,
  0xa2bfe8a14cf10364n,
  0xa81a664bbc423001n,
  0xc24b8b70d0f89791n,
  0xc76c51a30654be30n,
  0xd192e819d6ef5218n,
  0xd69906245565a910n,
  0xf40e35855771202an,
  0x106aa07032bbd1b8n,
  0x19a4c116b8d2d0c8n,
  0x1e376c085141ab53n,
  0x2748774cdf8eeb99n,
  0x34b0bcb5e19b48a8n,
  0x391c0cb3c5c95a63n,
  0x4ed8aa4ae3418acbn,
  0x5b9cca4f7763e373n,
  0x682e6ff3d6b2b8a3n,
  0x748f82ee5defb2fcn,
  0x78a5636f43172f60n,
  0x84c87814a1f0ab72n,
  0x8cc702081a6439ecn,
  0x90befffa23631e28n,
  0xa4506cebde82bde9n,
  0xbef9a3f7b2c67915n,
  0xc67178f2e372532bn,
  0xca273eceea26619cn,
  0xd186b8c721c0c207n,
  0xeada7dd6cde0eb1en,
  0xf57d4f7fee6ed178n,
  0x06f067aa72176fban,
  0x0a637dc5a2c898a6n,
  0x113f9804bef90daen,
  0x1b710b35131c471bn,
  0x28db77f523047d84n,
  0x32caab7b40c72493n,
  0x3c9ebe0a15c9bebcn,
  0x431d67c49c100d4cn,
  0x4cc5d4becb3e42b6n,
  0x597f299cfc657e2an,
  0x5fcb6fab3ad6faecn,
  0x6c44198c4a475817n
]);

// node_modules/@oslojs/encoding/dist/base32.js
var EncodingPadding;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding || (EncodingPadding = {}));
var DecodingPadding;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding || (DecodingPadding = {}));

// node_modules/@oslojs/encoding/dist/base64.js
function encodeBase64(bytes) {
  return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding2.Include);
}
function encodeBase64urlNoPadding(bytes) {
  return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding2.None);
}
function encodeBase64_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i = 0; i < bytes.byteLength; i += 3) {
    let buffer = 0;
    let bufferBitSize = 0;
    for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {
      buffer = buffer << 8 | bytes[i + j];
      bufferBitSize += 8;
    }
    for (let j = 0; j < 4; j++) {
      if (bufferBitSize >= 6) {
        result += alphabet[buffer >> bufferBitSize - 6 & 63];
        bufferBitSize -= 6;
      } else if (bufferBitSize > 0) {
        result += alphabet[buffer << 6 - bufferBitSize & 63];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding2.Include) {
        result += "=";
      }
    }
  }
  return result;
}
var base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var EncodingPadding2;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding2 || (EncodingPadding2 = {}));
var DecodingPadding2;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding2 || (DecodingPadding2 = {}));

// node_modules/remix-auth-oauth2/build/lib/authorization-code.js
var AuthorizationCode;
(function(AuthorizationCode2) {
  class AuthorizationURL extends URL {
    constructor(authorizationEndpoint, clientId) {
      super(authorizationEndpoint);
      this.searchParams.set("response_type", "code");
      this.searchParams.set("client_id", clientId);
    }
    setRedirectURI(redirectURI) {
      this.searchParams.set("redirect_uri", redirectURI);
    }
    addScopes(...scopes) {
      if (scopes.length < 1) {
        return;
      }
      let scopeValue = scopes.join(" ");
      const existingScopes = this.searchParams.get("scope");
      if (existingScopes !== null)
        scopeValue = ` ${existingScopes}`;
      this.searchParams.set("scope", scopeValue);
    }
    setState(state) {
      this.searchParams.set("state", state);
    }
    setS256CodeChallenge(codeVerifier) {
      const codeChallengeBytes = sha256(new TextEncoder().encode(codeVerifier));
      const codeChallenge = encodeBase64urlNoPadding(codeChallengeBytes);
      this.searchParams.set("code_challenge", codeChallenge);
      this.searchParams.set("code_challenge_method", "S256");
    }
    setPlainCodeChallenge(codeVerifier) {
      this.searchParams.set("code_challenge", codeVerifier);
      this.searchParams.set("code_challenge_method", "plain");
    }
  }
  AuthorizationCode2.AuthorizationURL = AuthorizationURL;
})(AuthorizationCode || (AuthorizationCode = {}));

// node_modules/remix-auth-oauth2/build/lib/generator.js
var Generator;
(function(Generator2) {
  function codeVerifier() {
    const randomValues = new Uint8Array(32);
    crypto.getRandomValues(randomValues);
    return encodeBase64urlNoPadding(randomValues);
  }
  Generator2.codeVerifier = codeVerifier;
  function state() {
    const randomValues = new Uint8Array(32);
    crypto.getRandomValues(randomValues);
    return encodeBase64urlNoPadding(randomValues);
  }
  Generator2.state = state;
})(Generator || (Generator = {}));

// node_modules/remix-auth-oauth2/build/lib/request.js
var OAuth2Request;
(function(OAuth2Request2) {
  class Context {
    constructor(method) {
      __publicField(this, "method");
      __publicField(this, "body", new URLSearchParams());
      __publicField(this, "headers", new Headers());
      this.method = method;
      this.headers.set("Content-Type", "application/x-www-form-urlencoded");
      this.headers.set("Accept", "application/json");
      this.headers.set("User-Agent", "oslo");
    }
    setClientId(clientId) {
      this.body.set("client_id", clientId);
    }
    authenticateWithRequestBody(clientId, clientSecret) {
      this.setClientId(clientId);
      this.body.set("client_secret", clientSecret);
    }
    authenticateWithHTTPBasicAuth(clientId, clientSecret) {
      const authorizationHeader = `Basic ${encodeBase64(new TextEncoder().encode(`${clientId}:${clientSecret}`))}`;
      this.headers.set("Authorization", authorizationHeader);
    }
    toRequest(url) {
      return new Request(url, {
        method: this.method,
        body: this.body,
        headers: this.headers
      });
    }
  }
  OAuth2Request2.Context = Context;
  class Error2 extends globalThis.Error {
    constructor(message, request, context, responseHeaders, options) {
      super(message);
      __publicField(this, "request");
      __publicField(this, "context");
      __publicField(this, "description");
      __publicField(this, "uri");
      __publicField(this, "responseHeaders");
      this.request = request;
      this.context = context;
      this.responseHeaders = responseHeaders;
      this.description = (options == null ? void 0 : options.description) ?? null;
      this.uri = (options == null ? void 0 : options.uri) ?? null;
    }
  }
  OAuth2Request2.Error = Error2;
})(OAuth2Request || (OAuth2Request = {}));

// node_modules/@oslojs/oauth2/dist/index.js
var OAuth2RequestResult = class {
  constructor(body) {
    __publicField(this, "body");
    this.body = body;
  }
  hasErrorCode() {
    return "error" in this.body && typeof this.body.error === "string";
  }
  errorCode() {
    if ("error" in this.body && typeof this.body.error === "string") {
      return this.body.error;
    }
    throw new Error("Missing or invalid 'error' field");
  }
  hasErrorDescription() {
    return "error_description" in this.body && typeof this.body.error_description === "string";
  }
  errorDescription() {
    if ("error_description" in this.body && typeof this.body.error_description === "string") {
      return this.body.error_description;
    }
    throw new Error("Missing or invalid 'error_description' field");
  }
  hasErrorURI() {
    return "error_uri" in this.body && typeof this.body.error_uri === "string";
  }
  errorURI() {
    if ("error_uri" in this.body && typeof this.body.error_uri === "string") {
      return this.body.error_uri;
    }
    throw new Error("Missing or invalid 'error_uri' field");
  }
  hasState() {
    return "state" in this.body && typeof this.body.state === "string";
  }
  state() {
    if ("state" in this.body && typeof this.body.state === "string") {
      return this.body.state;
    }
    throw new Error("Missing or invalid 'state' field");
  }
};
var TokenRequestResult = class extends OAuth2RequestResult {
  tokenType() {
    if ("token_type" in this.body && typeof this.body.token_type === "string") {
      return this.body.token_type;
    }
    throw new Error("Missing or invalid 'token_type' field");
  }
  accessToken() {
    if ("access_token" in this.body && typeof this.body.access_token === "string") {
      return this.body.access_token;
    }
    throw new Error("Missing or invalid 'access_token' field");
  }
  accessTokenExpiresInSeconds() {
    if ("expires_in" in this.body && typeof this.body.expires_in === "number") {
      return this.body.expires_in;
    }
    throw new Error("Missing or invalid 'expires_in' field");
  }
  accessTokenExpiresAt() {
    return new Date(Date.now() + this.accessTokenExpiresInSeconds() * 1e3);
  }
  hasRefreshToken() {
    return "refresh_token" in this.body && typeof this.body.refresh_token === "string";
  }
  refreshToken() {
    if ("refresh_token" in this.body && typeof this.body.refresh_token === "string") {
      return this.body.refresh_token;
    }
    throw new Error("Missing or invalid 'refresh_token' field");
  }
  hasScopes() {
    return "scope" in this.body && typeof this.body.scope === "string";
  }
  scopes() {
    if ("scope" in this.body && typeof this.body.scope === "string") {
      return this.body.scope.split(" ");
    }
    throw new Error("Missing or invalid 'scope' field");
  }
};

// node_modules/remix-auth-oauth2/build/lib/token.js
var Token;
(function(Token2) {
  let Request3;
  (function(Request4) {
    class Context extends OAuth2Request.Context {
      constructor(authorizationCode) {
        super("POST");
        this.body.set("grant_type", "authorization_code");
        this.body.set("code", authorizationCode);
      }
      setCodeVerifier(codeVerifier) {
        this.body.set("code_verifier", codeVerifier);
      }
      setRedirectURI(redirectURI) {
        this.body.set("redirect_uri", redirectURI);
      }
    }
    Request4.Context = Context;
    async function send(endpoint, context, options) {
      let request = context.toRequest(endpoint);
      let response = await fetch(request, { signal: options == null ? void 0 : options.signal });
      let body = await response.json();
      let result = new Result(body);
      if (result.hasErrorCode()) {
        throw new OAuth2Request.Error(result.errorCode(), request, context, response.headers, {
          description: result.hasErrorDescription() ? result.errorDescription() : void 0,
          uri: result.hasErrorURI() ? result.errorURI() : void 0
        });
      }
      return result.toJSON();
    }
    Request4.send = send;
    class Result extends TokenRequestResult {
      toJSON() {
        return {
          ...this.body,
          access_token: this.accessToken(),
          token_type: this.tokenType(),
          ..."expires_in" in this.body && {
            expires_in: this.accessTokenExpiresInSeconds()
          },
          ...this.hasScopes() && { scope: this.scopes().join(" ") },
          ...this.hasRefreshToken() && { refresh_token: this.refreshToken() }
        };
      }
    }
    Request4.Result = Result;
  })(Request3 = Token2.Request || (Token2.Request = {}));
  let RevocationRequest;
  (function(RevocationRequest2) {
    class Context extends OAuth2Request.Context {
      constructor(token) {
        super("POST");
        this.body.set("token", token);
      }
      setTokenTypeHint(tokenType) {
        if (tokenType === "access_token") {
          this.body.set("token_type_hint", "access_token");
        } else if (tokenType === "refresh_token") {
          this.body.set("token_type_hint", "refresh_token");
        }
      }
    }
    RevocationRequest2.Context = Context;
    async function send(endpoint, context, options) {
      let request = context.toRequest(endpoint);
      let response = await fetch(request, { signal: options == null ? void 0 : options.signal });
      let body = await response.json();
      let result = new OAuth2RequestResult(body);
      if (result.hasErrorCode()) {
        throw new OAuth2Request.Error(result.errorCode(), request, context, response.headers, {
          description: result.hasErrorDescription() ? result.errorDescription() : void 0,
          uri: result.hasErrorURI() ? result.errorURI() : void 0
        });
      }
    }
    RevocationRequest2.send = send;
  })(RevocationRequest = Token2.RevocationRequest || (Token2.RevocationRequest = {}));
  let RefreshRequest;
  (function(RefreshRequest2) {
    class Context extends OAuth2Request.Context {
      constructor(refreshToken) {
        super("POST");
        this.body.set("grant_type", "refresh_token");
        this.body.set("refresh_token", refreshToken);
      }
      addScopes(...scopes) {
        if (scopes.length < 1) {
          return;
        }
        let scopeValue = scopes.join(" ");
        const existingScopes = this.body.get("scope");
        if (existingScopes !== null) {
          scopeValue = `${scopeValue} ${existingScopes}`;
        }
        this.body.set("scope", scopeValue);
      }
    }
    RefreshRequest2.Context = Context;
  })(RefreshRequest = Token2.RefreshRequest || (Token2.RefreshRequest = {}));
})(Token || (Token = {}));

// node_modules/remix-auth-oauth2/build/index.js
var debug = (0, import_debug.default)("OAuth2Strategy");
var OAuth2Strategy = class extends import_remix_auth.Strategy {
  constructor(options, verify) {
    super(verify);
    __publicField(this, "name", "oauth2");
    __publicField(this, "sessionStateKey", "oauth2:state");
    __publicField(this, "sessionCodeVerifierKey", "oauth2:codeVerifier");
    __publicField(this, "options");
    this.options = {
      codeChallengeMethod: "S256",
      authenticateWith: "request_body",
      ...options
    };
  }
  async authenticate(request, sessionStorage, options) {
    debug("Request URL", request.url);
    let url = new URL(request.url);
    if (url.searchParams.has("error")) {
      return this.failure("Error on authentication", request, sessionStorage, options, new OAuth2Error(request, {
        error: url.searchParams.get("error") ?? void 0,
        error_description: url.searchParams.get("error_description") ?? void 0,
        error_uri: url.searchParams.get("error_uri") ?? void 0
      }));
    }
    let session = await sessionStorage.getSession(request.headers.get("Cookie"));
    let stateUrl = url.searchParams.get("state");
    if (!stateUrl) {
      debug("No state found in the URL, redirecting to authorization endpoint");
      let state = Generator.state();
      session.set(this.sessionStateKey, state);
      debug("State", state);
      let codeVerifier2 = Generator.codeVerifier();
      session.set(this.sessionCodeVerifierKey, codeVerifier2);
      debug("Code verifier", codeVerifier2);
      let authorizationURL = new AuthorizationCode.AuthorizationURL(this.options.authorizationEndpoint.toString(), this.options.clientId);
      authorizationURL.setRedirectURI(this.options.redirectURI.toString());
      authorizationURL.setState(state);
      if (this.options.scopes)
        authorizationURL.addScopes(...this.options.scopes);
      if (this.options.codeChallengeMethod === "S256") {
        authorizationURL.setS256CodeChallenge(codeVerifier2);
      } else if (this.options.codeChallengeMethod === "plain") {
        authorizationURL.setPlainCodeChallenge(codeVerifier2);
      }
      authorizationURL.search = this.authorizationParams(authorizationURL.searchParams, request).toString();
      debug("Authorization URL", authorizationURL.toString());
      throw redirect(authorizationURL.toString(), {
        headers: {
          "Set-Cookie": await sessionStorage.commitSession(session)
        }
      });
    }
    let code = url.searchParams.get("code");
    let codeVerifier = session.get(this.sessionCodeVerifierKey);
    if (!code && url.searchParams.has("error")) {
      return this.failure("Error during authentication", request, sessionStorage, options, new OAuth2Error(request, {
        error: url.searchParams.get("error") ?? void 0,
        error_description: url.searchParams.get("error_description") ?? void 0,
        error_uri: url.searchParams.get("error_uri") ?? void 0
      }));
    }
    if (!code) {
      return this.failure("Missing code in the URL", request, sessionStorage, options, new ReferenceError("Missing code in the URL"));
    }
    let stateSession = session.get(this.sessionStateKey);
    debug("State from session", stateSession);
    if (!stateSession) {
      return await this.failure("Missing state on session.", request, sessionStorage, options, new ReferenceError("Missing state on session."));
    }
    if (stateSession === stateUrl) {
      debug("State is valid");
      session.unset(this.sessionStateKey);
    } else {
      return await this.failure("State in URL doesn't match state in session.", request, sessionStorage, options, new RangeError("State in URL doesn't match state in session."));
    }
    try {
      debug("Validating authorization code");
      let context = new Token.Request.Context(code);
      context.setRedirectURI(this.options.redirectURI.toString());
      context.setCodeVerifier(codeVerifier);
      if (this.options.authenticateWith === "http_basic_auth") {
        context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
      } else if (this.options.authenticateWith === "request_body") {
        context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
      }
      let tokens = await Token.Request.send(this.options.tokenEndpoint.toString(), context, { signal: request.signal });
      debug("Fetching the user profile");
      let profile = await this.userProfile(tokens);
      debug("Verifying the user profile");
      let user = await this.verify({
        tokens,
        profile,
        context: options.context,
        request
      });
      debug("User authenticated");
      return this.success(user, request, sessionStorage, options);
    } catch (error) {
      if (error instanceof Response)
        throw error;
      debug("Failed to verify user", error);
      if (error instanceof Error) {
        return await this.failure(error.message, request, sessionStorage, options, error);
      }
      if (typeof error === "string") {
        return await this.failure(error, request, sessionStorage, options, new Error(error));
      }
      return await this.failure("Unknown error", request, sessionStorage, options, new Error(JSON.stringify(error, null, 2)));
    }
  }
  async userProfile(tokens) {
    return { provider: "oauth2" };
  }
  /**
   * Return extra parameters to be included in the authorization request.
   *
   * Some OAuth 2.0 providers allow additional, non-standard parameters to be
   * included when requesting authorization.  Since these parameters are not
   * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
   * strategies can override this function in order to populate these
   * parameters as required by the provider.
   */
  authorizationParams(params, request) {
    return new URLSearchParams(params);
  }
  /**
   * Get new tokens using a refresh token.
   * @param refreshToken The refresh token to use
   * @param options Optional options to override the default strategy options
   * @returns A promise that resolves to the new tokens
   */
  refreshToken(refreshToken, options = {}) {
    let scopes = options.scopes ?? this.options.scopes ?? [];
    let context = new Token.RefreshRequest.Context(refreshToken);
    context.addScopes(...scopes);
    if (this.options.authenticateWith === "http_basic_auth") {
      context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
    } else if (this.options.authenticateWith === "request_body") {
      context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
    }
    return Token.Request.send(this.options.tokenEndpoint.toString(), context, { signal: options.signal });
  }
  async revokeToken(token, options = {}) {
    if (this.options.tokenRevocationEndpoint === void 0) {
      throw new Error("Token revocation endpoint is not set");
    }
    let context = new Token.RevocationRequest.Context(token);
    if (options.tokenType)
      context.setTokenTypeHint(options.tokenType);
    if (this.options.authenticateWith === "http_basic_auth") {
      context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
    } else if (this.options.authenticateWith === "request_body") {
      context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
    }
    await Token.RevocationRequest.send(this.options.tokenRevocationEndpoint, context, { signal: options.signal });
  }
};
var OAuth2Error = class extends Error {
  constructor(request, body) {
    super(body.error ?? "");
    __publicField(this, "name", "OAuth2Error");
    __publicField(this, "request");
    __publicField(this, "description");
    __publicField(this, "uri");
    this.request = request;
    this.description = body.error_description ?? null;
    this.uri = body.error_uri ?? null;
  }
};
var OAuth2RequestError = OAuth2Request.Error;

// node_modules/remix-auth-github/build/lib/request.js
var Request2;
(function(Request3) {
  class Context {
    constructor(method, userAgent) {
      __publicField(this, "method");
      __publicField(this, "body", /* @__PURE__ */ new Map());
      __publicField(this, "headers", new Headers());
      this.method = method;
      this.headers.set("Content-Type", "application/json");
      this.headers.set("Accept", "application/vnd.github.v3+json");
      this.headers.set("User-Agent", userAgent);
    }
    authorize(token) {
      this.headers.set("Authorization", `token ${token}`);
    }
    toRequest(url) {
      let init = { method: this.method, headers: this.headers };
      if (init.method !== "GET" && init.method !== "HEAD") {
        init.body = JSON.stringify(Object.fromEntries(this.body));
      }
      return new globalThis.Request(url, init);
    }
  }
  Request3.Context = Context;
})(Request2 || (Request2 = {}));

// node_modules/remix-auth-github/build/lib/emails.js
var Emails;
(function(Emails2) {
  class Response2 {
    constructor(body) {
      __publicField(this, "body");
      this.body = body;
    }
    emails() {
      if (!Array.isArray(this.body))
        return [];
      let isValid = this.body.every((item) => {
        if (typeof item !== "object")
          return false;
        if (item === null)
          return false;
        if (Array.isArray(item))
          return false;
        return "email" in item && "verified" in item && "primary" in item && "visibility" in item;
      });
      if (!isValid)
        return [];
      let emails = this.body;
      return emails.filter(({ verified }) => verified).sort((a, b) => {
        if (a.primary && !b.primary)
          return -1;
        if (!a.primary && b.primary)
          return 1;
        return 0;
      }).map(({ email, primary }) => ({
        value: email,
        type: primary ? "primary" : "secondary"
      }));
    }
  }
  Emails2.Response = Response2;
  async function send(endpoint, context, options) {
    let request = context.toRequest(endpoint);
    let response = await fetch(request, { signal: options == null ? void 0 : options.signal });
    let body = await response.json();
    let result = new Response2(body);
    return result.emails();
  }
  Emails2.send = send;
})(Emails || (Emails = {}));

// node_modules/remix-auth-github/build/lib/user-profile.js
var UserProfile;
(function(UserProfile2) {
  async function send(endpoint, context, options) {
    let request = context.toRequest(endpoint);
    let response = await fetch(request, { signal: options == null ? void 0 : options.signal });
    let body = await response.json();
    return body;
  }
  UserProfile2.send = send;
})(UserProfile || (UserProfile = {}));

// node_modules/remix-auth-github/build/index.js
var GitHubStrategyDefaultName = "github";
var GitHubStrategyDefaultScope = "user:email";
var GitHubStrategyScopeSeperator = " ";
var GitHubStrategy = class extends OAuth2Strategy {
  constructor({ allowSignup, userAgent, scopes = [GitHubStrategyDefaultScope], userInfoEndpoint = "https://api.github.com/user", userEmailsEndpoint = "https://api.github.com/user/emails", authorizationEndpoint = "https://github.com/login/oauth/authorize", tokenEndpoint = "https://github.com/login/oauth/access_token", ...options }, verify) {
    super({
      ...options,
      scopes,
      authorizationEndpoint,
      tokenEndpoint
    }, verify);
    __publicField(this, "name", GitHubStrategyDefaultName);
    __publicField(this, "allowSignup");
    __publicField(this, "userAgent");
    __publicField(this, "userInfoEndpoint");
    __publicField(this, "userEmailsEndpoint");
    this.allowSignup = allowSignup ?? true;
    this.userAgent = userAgent ?? "Remix Auth";
    this.userInfoEndpoint = new URL(userInfoEndpoint);
    this.userEmailsEndpoint = new URL(userEmailsEndpoint);
  }
  authorizationParams(params) {
    let searchParams = new URLSearchParams(params);
    if (this.allowSignup)
      searchParams.set("allow_signup", "true");
    return searchParams;
  }
  async userEmails(accessToken) {
    let context = new Request2.Context("GET", this.userAgent);
    context.authorize(accessToken);
    return await Emails.send(this.userEmailsEndpoint, context);
  }
  async userProfile(tokens) {
    var _a;
    let context = new Request2.Context("GET", this.userAgent);
    context.authorize(tokens.access_token);
    let profile = await UserProfile.send(this.userInfoEndpoint, context);
    let emails = [{ value: profile.email }];
    if ((_a = this.options.scopes) == null ? void 0 : _a.includes(GitHubStrategyDefaultScope)) {
      emails = await this.userEmails(tokens.access_token);
    }
    return {
      provider: "github",
      displayName: profile.login,
      id: profile.id.toString(),
      name: {
        familyName: profile.name,
        givenName: profile.name,
        middleName: profile.name
      },
      emails,
      photos: [{ value: profile.avatar_url }],
      _json: profile
    };
  }
};
export {
  GitHubStrategy,
  GitHubStrategyDefaultName,
  GitHubStrategyDefaultScope,
  GitHubStrategyScopeSeperator
};
//# sourceMappingURL=remix-auth-github.js.map
