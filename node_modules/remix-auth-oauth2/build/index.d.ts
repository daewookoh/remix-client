import { type AppLoadContext, type SessionStorage } from "@remix-run/server-runtime";
import { type AuthenticateOptions, Strategy, type StrategyVerifyCallback } from "remix-auth";
import { OAuth2Request } from "./lib/request.js";
import { Token } from "./lib/token.js";
export interface OAuth2Profile {
    provider: string;
    id?: string;
    displayName?: string;
    name?: {
        familyName?: string;
        givenName?: string;
        middleName?: string;
    };
    emails?: Array<{
        value: string;
        type?: string;
    }>;
    photos?: Array<{
        value: string;
    }>;
}
type URLConstructor = ConstructorParameters<typeof URL>[0];
export interface OAuth2StrategyOptions {
    /**
     * This is the Client ID of your application, provided to you by the Identity
     * Provider you're using to authenticate users.
     */
    clientId: string;
    /**
     * This is the Client Secret of your application, provided to you by the
     * Identity Provider you're using to authenticate users.
     */
    clientSecret: string;
    /**
     * The endpoint the Identity Provider asks you to send users to log in, or
     * authorize your application.
     */
    authorizationEndpoint: URLConstructor;
    /**
     * The endpoint the Identity Provider uses to let's you exchange an access
     * code for an access and refresh token.
     */
    tokenEndpoint: URLConstructor;
    /**
     * The URL of your application where the Identity Provider will redirect the
     * user after they've logged in or authorized your application.
     */
    redirectURI: URLConstructor;
    /**
     * The endpoint the Identity Provider uses to revoke an access or refresh
     * token, this can be useful to log out the user.
     */
    tokenRevocationEndpoint?: URLConstructor;
    /**
     * The scopes you want to request from the Identity Provider, this is a list
     * of strings that represent the permissions you want to request from the
     * user.
     */
    scopes?: string[];
    /**
     * The code challenge method to use when sending the authorization request.
     * This is used when the Identity Provider requires a code challenge to be
     * sent with the authorization request.
     * @default "S256"
     */
    codeChallengeMethod?: "S256" | "plain";
    /**
     * The method to use to authenticate with the Identity Provider, this can be
     * either `http_basic_auth` or `request_body`.
     * @default "request_body"
     */
    authenticateWith?: "http_basic_auth" | "request_body";
}
export interface OAuth2StrategyVerifyParams<Profile extends OAuth2Profile, ExtraTokenParams extends Record<string, unknown> = Record<string, never>> {
    tokens: Token.Response.Body & ExtraTokenParams;
    profile: Profile;
    request: Request;
    context?: AppLoadContext;
}
export declare class OAuth2Strategy<User, Profile extends OAuth2Profile, ExtraParams extends Record<string, unknown> = Record<string, never>> extends Strategy<User, OAuth2StrategyVerifyParams<Profile, ExtraParams>> {
    name: string;
    protected sessionStateKey: string;
    protected sessionCodeVerifierKey: string;
    protected options: OAuth2StrategyOptions;
    constructor(options: OAuth2StrategyOptions, verify: StrategyVerifyCallback<User, OAuth2StrategyVerifyParams<Profile, ExtraParams>>);
    authenticate(request: Request, sessionStorage: SessionStorage, options: AuthenticateOptions): Promise<User>;
    protected userProfile(tokens: Token.Response.Body): Promise<Profile>;
    /**
     * Return extra parameters to be included in the authorization request.
     *
     * Some OAuth 2.0 providers allow additional, non-standard parameters to be
     * included when requesting authorization.  Since these parameters are not
     * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
     * strategies can override this function in order to populate these
     * parameters as required by the provider.
     */
    protected authorizationParams(params: URLSearchParams, request: Request): URLSearchParams;
    /**
     * Get new tokens using a refresh token.
     * @param refreshToken The refresh token to use
     * @param options Optional options to override the default strategy options
     * @returns A promise that resolves to the new tokens
     */
    refreshToken(refreshToken: string, options?: Partial<Pick<OAuth2StrategyOptions, "scopes">> & {
        signal?: AbortSignal;
    }): Promise<Token.Response.Body & ExtraParams>;
    revokeToken(token: string, options?: {
        signal?: AbortSignal;
        tokenType?: "access_token" | "refresh_token";
    }): Promise<void>;
}
export interface TokenErrorResponseBody {
    error: string;
    error_description?: string;
    error_uri?: string;
}
export declare class OAuth2Error extends Error {
    name: string;
    request: Request;
    description: string | null;
    uri: string | null;
    constructor(request: Request, body: Partial<TokenErrorResponseBody>);
}
export declare const OAuth2RequestError: typeof OAuth2Request.Error;
export type TokenResponseBody = Token.Response.Body;
export {};
