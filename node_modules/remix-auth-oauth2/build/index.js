import { redirect, } from "@remix-run/server-runtime";
import createDebug from "debug";
import { Strategy, } from "remix-auth";
import { AuthorizationCode } from "./lib/authorization-code.js";
import { Generator } from "./lib/generator.js";
import { OAuth2Request } from "./lib/request.js";
import { Token } from "./lib/token.js";
let debug = createDebug("OAuth2Strategy");
export class OAuth2Strategy extends Strategy {
    name = "oauth2";
    sessionStateKey = "oauth2:state";
    sessionCodeVerifierKey = "oauth2:codeVerifier";
    options;
    constructor(options, verify) {
        super(verify);
        this.options = {
            codeChallengeMethod: "S256",
            authenticateWith: "request_body",
            ...options,
        };
    }
    async authenticate(request, sessionStorage, options) {
        debug("Request URL", request.url);
        let url = new URL(request.url);
        if (url.searchParams.has("error")) {
            return this.failure("Error on authentication", request, sessionStorage, options, new OAuth2Error(request, {
                error: url.searchParams.get("error") ?? undefined,
                error_description: url.searchParams.get("error_description") ?? undefined,
                error_uri: url.searchParams.get("error_uri") ?? undefined,
            }));
        }
        let session = await sessionStorage.getSession(request.headers.get("Cookie"));
        let stateUrl = url.searchParams.get("state");
        if (!stateUrl) {
            debug("No state found in the URL, redirecting to authorization endpoint");
            let state = Generator.state();
            session.set(this.sessionStateKey, state);
            debug("State", state);
            let codeVerifier = Generator.codeVerifier();
            session.set(this.sessionCodeVerifierKey, codeVerifier);
            debug("Code verifier", codeVerifier);
            let authorizationURL = new AuthorizationCode.AuthorizationURL(this.options.authorizationEndpoint.toString(), this.options.clientId);
            authorizationURL.setRedirectURI(this.options.redirectURI.toString());
            authorizationURL.setState(state);
            if (this.options.scopes)
                authorizationURL.addScopes(...this.options.scopes);
            if (this.options.codeChallengeMethod === "S256") {
                authorizationURL.setS256CodeChallenge(codeVerifier);
            }
            else if (this.options.codeChallengeMethod === "plain") {
                authorizationURL.setPlainCodeChallenge(codeVerifier);
            }
            // Extend authorization URL with extra non-standard params
            authorizationURL.search = this.authorizationParams(authorizationURL.searchParams, request).toString();
            debug("Authorization URL", authorizationURL.toString());
            throw redirect(authorizationURL.toString(), {
                headers: {
                    "Set-Cookie": await sessionStorage.commitSession(session),
                },
            });
        }
        let code = url.searchParams.get("code");
        let codeVerifier = session.get(this.sessionCodeVerifierKey);
        if (!code && url.searchParams.has("error")) {
            return this.failure("Error during authentication", request, sessionStorage, options, new OAuth2Error(request, {
                error: url.searchParams.get("error") ?? undefined,
                error_description: url.searchParams.get("error_description") ?? undefined,
                error_uri: url.searchParams.get("error_uri") ?? undefined,
            }));
        }
        if (!code) {
            return this.failure("Missing code in the URL", request, sessionStorage, options, new ReferenceError("Missing code in the URL"));
        }
        let stateSession = session.get(this.sessionStateKey);
        debug("State from session", stateSession);
        if (!stateSession) {
            return await this.failure("Missing state on session.", request, sessionStorage, options, new ReferenceError("Missing state on session."));
        }
        if (stateSession === stateUrl) {
            debug("State is valid");
            session.unset(this.sessionStateKey);
        }
        else {
            return await this.failure("State in URL doesn't match state in session.", request, sessionStorage, options, new RangeError("State in URL doesn't match state in session."));
        }
        try {
            debug("Validating authorization code");
            let context = new Token.Request.Context(code);
            context.setRedirectURI(this.options.redirectURI.toString());
            context.setCodeVerifier(codeVerifier);
            if (this.options.authenticateWith === "http_basic_auth") {
                context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
            }
            else if (this.options.authenticateWith === "request_body") {
                context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
            }
            let tokens = await Token.Request.send(this.options.tokenEndpoint.toString(), context, { signal: request.signal });
            debug("Fetching the user profile");
            let profile = await this.userProfile(tokens);
            debug("Verifying the user profile");
            let user = await this.verify({
                tokens,
                profile,
                context: options.context,
                request,
            });
            debug("User authenticated");
            return this.success(user, request, sessionStorage, options);
        }
        catch (error) {
            // Allow responses to pass-through
            if (error instanceof Response)
                throw error;
            debug("Failed to verify user", error);
            if (error instanceof Error) {
                return await this.failure(error.message, request, sessionStorage, options, error);
            }
            if (typeof error === "string") {
                return await this.failure(error, request, sessionStorage, options, new Error(error));
            }
            return await this.failure("Unknown error", request, sessionStorage, options, new Error(JSON.stringify(error, null, 2)));
        }
    }
    async userProfile(tokens) {
        return { provider: "oauth2" };
    }
    /**
     * Return extra parameters to be included in the authorization request.
     *
     * Some OAuth 2.0 providers allow additional, non-standard parameters to be
     * included when requesting authorization.  Since these parameters are not
     * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
     * strategies can override this function in order to populate these
     * parameters as required by the provider.
     */
    authorizationParams(params, request) {
        return new URLSearchParams(params);
    }
    /**
     * Get new tokens using a refresh token.
     * @param refreshToken The refresh token to use
     * @param options Optional options to override the default strategy options
     * @returns A promise that resolves to the new tokens
     */
    refreshToken(refreshToken, options = {}) {
        let scopes = options.scopes ?? this.options.scopes ?? [];
        let context = new Token.RefreshRequest.Context(refreshToken);
        context.addScopes(...scopes);
        if (this.options.authenticateWith === "http_basic_auth") {
            context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
        }
        else if (this.options.authenticateWith === "request_body") {
            context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
        }
        return Token.Request.send(this.options.tokenEndpoint.toString(), context, { signal: options.signal });
    }
    async revokeToken(token, options = {}) {
        if (this.options.tokenRevocationEndpoint === undefined) {
            throw new Error("Token revocation endpoint is not set");
        }
        let context = new Token.RevocationRequest.Context(token);
        if (options.tokenType)
            context.setTokenTypeHint(options.tokenType);
        if (this.options.authenticateWith === "http_basic_auth") {
            context.authenticateWithHTTPBasicAuth(this.options.clientId, this.options.clientSecret);
        }
        else if (this.options.authenticateWith === "request_body") {
            context.authenticateWithRequestBody(this.options.clientId, this.options.clientSecret);
        }
        await Token.RevocationRequest.send(this.options.tokenRevocationEndpoint, context, { signal: options.signal });
    }
}
export class OAuth2Error extends Error {
    name = "OAuth2Error";
    request;
    description;
    uri;
    constructor(request, body) {
        super(body.error ?? "");
        this.request = request;
        this.description = body.error_description ?? null;
        this.uri = body.error_uri ?? null;
    }
}
export const OAuth2RequestError = OAuth2Request.Error;
//# sourceMappingURL=index.js.map